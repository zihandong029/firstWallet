<!DOCTYPE html>
<html>
<head>
    <title>地址如何连接网络 - 深度解析</title>
    <style>
        body {
            font-family: 'JetBrains Mono', monospace;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #e0e6ed;
            line-height: 1.6;
        }
        .container {
            background: rgba(255, 255, 255, 0.05);
            padding: 30px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .section {
            background: rgba(255, 255, 255, 0.03);
            padding: 25px;
            margin: 20px 0;
            border-radius: 12px;
            border-left: 4px solid #00d4aa;
        }
        .network-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
            margin: 15px 0;
            border-radius: 10px;
            color: white;
        }
        .code {
            background: #0d1117;
            color: #c9d1d9;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            overflow-x: auto;
            margin: 10px 0;
            border: 1px solid #30363d;
        }
        .highlight {
            background: #ffd700;
            color: #000;
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: bold;
        }
        .address {
            background: #2ea043;
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-family: monospace;
            font-size: 14px;
            word-break: break-all;
        }
        button {
            background: linear-gradient(45deg, #00d4aa, #667eea);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            margin: 10px 5px;
            transition: all 0.3s;
        }
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 212, 170, 0.4);
        }
        .step {
            background: rgba(102, 126, 234, 0.1);
            border: 1px solid rgba(102, 126, 234, 0.3);
            padding: 15px;
            margin: 10px 0;
            border-radius: 8px;
        }
        .warning {
            background: rgba(255, 193, 7, 0.1);
            border: 1px solid rgba(255, 193, 7, 0.3);
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
        }
        .network-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/ethers@6/dist/ethers.umd.min.js"></script>
</head>
<body>
    <div class="container">
        <h1>🌐 地址如何连接到具体网络</h1>
        
        <div class="section">
            <h2>🔑 核心概念</h2>
            <div class="step">
                <h4>1. 地址的通用性</h4>
                <p>同一个私钥在所有 EVM 兼容网络上都生成相同的地址</p>
                <div class="address">0x742d35Cc6065C0532C30c0C93c0f1C6F47c5c4F3</div>
                <p>↑ 这个地址在以太坊、BSC、Polygon、Arbitrum 等网络上都相同</p>
            </div>
            
            <div class="step">
                <h4>2. 网络通过 RPC 区分</h4>
                <p>虽然地址相同，但通过连接不同的 RPC 节点来访问不同网络上的数据</p>
            </div>
            
            <div class="step">
                <h4>3. ChainID 防止混淆</h4>
                <p>每个网络有唯一的 ChainID，防止交易在错误网络上执行</p>
            </div>
        </div>

        <div class="section">
            <h2>🌍 网络配置示例</h2>
            <div class="network-grid" id="networkGrid">
                <!-- 网络卡片将通过 JavaScript 生成 -->
            </div>
        </div>

        <div class="section">
            <h2>🔧 连接流程演示</h2>
            <button onclick="demonstrateConnection()">🚀 演示地址连接网络</button>
            <div id="connectionDemo"></div>
        </div>

        <div class="section">
            <h2>💰 余额查询演示</h2>
            <button onclick="checkBalancesAcrossNetworks()">💎 查看同一地址在不同网络的余额</button>
            <div id="balanceDemo"></div>
        </div>

        <div class="section">
            <h2>📊 交易签名演示</h2>
            <button onclick="demonstrateTransactionSigning()">✍️ 演示跨网络交易签名</button>
            <div id="transactionDemo"></div>
        </div>
    </div>

    <script>
        // 网络配置
        const networks = [
            {
                name: 'Ethereum Mainnet',
                rpcUrl: 'https://eth.llamarpc.com',
                chainId: 1,
                symbol: 'ETH',
                blockExplorer: 'https://etherscan.io',
                color: 'linear-gradient(135deg, #627eea 0%, #404bbf 100%)'
            },
            {
                name: 'Sepolia Testnet',
                rpcUrl: 'https://rpc.sepolia.org',
                chainId: 11155111,
                symbol: 'SEP',
                blockExplorer: 'https://sepolia.etherscan.io',
                color: 'linear-gradient(135deg, #ffa726 0%, #fb8c00 100%)'
            },
            {
                name: 'BSC Mainnet',
                rpcUrl: 'https://bsc-dataseed.binance.org',
                chainId: 56,
                symbol: 'BNB',
                blockExplorer: 'https://bscscan.com',
                color: 'linear-gradient(135deg, #f0b90b 0%, #d9940f 100%)'
            },
            {
                name: 'Polygon Mainnet',
                rpcUrl: 'https://polygon-rpc.com',
                chainId: 137,
                symbol: 'MATIC',
                blockExplorer: 'https://polygonscan.com',
                color: 'linear-gradient(135deg, #8247e5 0%, #6f42c1 100%)'
            }
        ];

        // 示例私钥和地址
        const DEMO_PRIVATE_KEY = "0x4c0883a69102937d6231471b5dbb6204fe5129617082792ae468d01a3f362318";
        const DEMO_ADDRESS = "0x742d35Cc6065C0532C30c0C93c0f1C6F47c5c4F3";

        // 页面加载时初始化
        window.onload = function() {
            console.log('🌐 地址网络连接演示页面已加载');
            renderNetworkCards();
        };

        // 渲染网络卡片
        function renderNetworkCards() {
            const grid = document.getElementById('networkGrid');
            
            networks.forEach(network => {
                const card = document.createElement('div');
                card.className = 'network-card';
                card.style.background = network.color;
                card.innerHTML = `
                    <h4>${network.name}</h4>
                    <div style="font-size: 12px; margin: 8px 0;">
                        <strong>ChainID:</strong> ${network.chainId}<br>
                        <strong>Symbol:</strong> ${network.symbol}<br>
                        <strong>RPC:</strong> ${network.rpcUrl}<br>
                        <strong>Explorer:</strong> <a href="${network.blockExplorer}" target="_blank" style="color: #fff;">查看</a>
                    </div>
                `;
                grid.appendChild(card);
            });
        }

        // 演示连接流程
        async function demonstrateConnection() {
            const demo = document.getElementById('connectionDemo');
            demo.innerHTML = '<h4>🔄 正在演示连接流程...</h4>';

            console.log('🔄 开始演示地址连接网络的流程...');

            let output = '';

            // 第1步：同一个私钥生成同一个地址
            output += `
                <div class="step">
                    <h4>第1步：私钥生成地址</h4>
                    <div class="code">
const privateKey = "${DEMO_PRIVATE_KEY}";
const wallet = new ethers.Wallet(privateKey);
console.log("地址:", wallet.address);
// 结果: ${DEMO_ADDRESS}
                    </div>
                    <p><span class="highlight">关键点</span>: 无论连接哪个网络，这个地址都不变！</p>
                </div>
            `;

            // 第2步：连接不同网络
            output += `
                <div class="step">
                    <h4>第2步：连接到不同网络</h4>
            `;

            for (let network of networks) {
                try {
                    console.log(\`🔌 连接到 \${network.name}...\`);
                    
                    const provider = new ethers.JsonRpcProvider(network.rpcUrl);
                    const connectedWallet = wallet.connect(provider);
                    
                    // 获取网络信息
                    const networkInfo = await provider.getNetwork();
                    const blockNumber = await provider.getBlockNumber();
                    
                    output += \`
                        <div class="code">
// 连接到 \${network.name}
const provider = new ethers.JsonRpcProvider("\${network.rpcUrl}");
const connectedWallet = wallet.connect(provider);

// 网络信息
ChainID: \${networkInfo.chainId}
当前区块: \${blockNumber}
地址: \${connectedWallet.address}  // 🔍 地址保持不变！
                        </div>
                    \`;
                    
                    console.log(\`✅ \${network.name} 连接成功\`);
                } catch (error) {
                    console.error(\`❌ \${network.name} 连接失败:\`, error);
                    output += \`
                        <div class="code">
❌ \${network.name} 连接失败: \${error.message}
                        </div>
                    \`;
                }
            }

            output += '</div>';

            // 第3步：解释机制
            output += `
                <div class="step">
                    <h4>第3步：理解连接机制</h4>
                    <div class="warning">
                        <h5>🔍 核心理解：</h5>
                        <ul>
                            <li><strong>地址不变</strong>: 同一私钥在所有网络上地址相同</li>
                            <li><strong>数据来源</strong>: 通过不同RPC节点获取不同网络的数据</li>
                            <li><strong>网络隔离</strong>: 每个网络有独立的状态和余额</li>
                            <li><strong>交易签名</strong>: ChainID确保交易只在指定网络有效</li>
                        </ul>
                    </div>
                </div>
            `;

            demo.innerHTML = output;
        }

        // 查看余额演示
        async function checkBalancesAcrossNetworks() {
            const demo = document.getElementById('balanceDemo');
            demo.innerHTML = '<h4>💰 正在查询各网络余额...</h4>';

            console.log('💰 开始查询同一地址在不同网络的余额...');

            let output = \`
                <div class="step">
                    <h4>💎 地址: \${DEMO_ADDRESS}</h4>
                    <p>同一个地址在不同网络上的余额：</p>
                </div>
            \`;

            for (let network of networks) {
                try {
                    console.log(\`💰 查询 \${network.name} 余额...\`);
                    
                    const provider = new ethers.JsonRpcProvider(network.rpcUrl);
                    const balance = await provider.getBalance(DEMO_ADDRESS);
                    const balanceInEther = ethers.formatEther(balance);
                    
                    output += \`
                        <div class="code">
\${network.name}:
  余额: \${balanceInEther} \${network.symbol}
  原始值: \${balance.toString()} wei
  ChainID: \${network.chainId}
                        </div>
                    \`;
                    
                    console.log(\`✅ \${network.name} 余额: \${balanceInEther} \${network.symbol}\`);
                } catch (error) {
                    console.error(\`❌ \${network.name} 查询失败:\`, error);
                    output += \`
                        <div class="code">
❌ \${network.name}: 查询失败 - \${error.message}
                        </div>
                    \`;
                }
            }

            output += \`
                <div class="warning">
                    <h5>💡 重要观察：</h5>
                    <ul>
                        <li>相同地址在不同网络上余额完全独立</li>
                        <li>在以太坊有余额不代表在BSC也有余额</li>
                        <li>需要在每个网络上单独转入资金</li>
                    </ul>
                </div>
            \`;

            demo.innerHTML = output;
        }

        // 交易签名演示
        async function demonstrateTransactionSigning() {
            const demo = document.getElementById('transactionDemo');
            demo.innerHTML = '<h4>✍️ 正在演示交易签名...</h4>';

            console.log('✍️ 开始演示跨网络交易签名...');

            const wallet = new ethers.Wallet(DEMO_PRIVATE_KEY);

            let output = \`
                <div class="step">
                    <h4>📝 创建交易对象</h4>
                    <div class="code">
// 基础交易参数
const transaction = {
  to: "0x0000000000000000000000000000000000000000",
  value: ethers.parseEther("0.001"),
  gasLimit: 21000,
  gasPrice: ethers.parseUnits("20", "gwei")
};
                    </div>
                </div>
            \`;

            // 为不同网络签名相同交易
            for (let network of networks.slice(0, 2)) { // 只演示前两个网络
                try {
                    const transaction = {
                        to: "0x0000000000000000000000000000000000000000",
                        value: ethers.parseEther("0.001"),
                        gasLimit: 21000,
                        gasPrice: ethers.parseUnits("20", "gwei"),
                        chainId: network.chainId  // 关键：指定网络
                    };

                    const signedTx = await wallet.signTransaction(transaction);
                    
                    output += \`
                        <div class="step">
                            <h4>\${network.name} 签名</h4>
                            <div class="code">
// \${network.name} (ChainID: \${network.chainId})
const transaction = {
  ...baseTransaction,
  chainId: \${network.chainId}  // 🔑 关键区别
};

const signedTx = await wallet.signTransaction(transaction);
签名结果: \${signedTx.substring(0, 50)}...

// 🔍 注意：相同交易在不同网络上签名结果不同！
                            </div>
                        </div>
                    \`;
                    
                    console.log(\`✅ \${network.name} 签名完成\`);
                } catch (error) {
                    console.error(\`❌ \${network.name} 签名失败:\`, error);
                }
            }

            output += \`
                <div class="warning">
                    <h5>🛡️ 安全机制：</h5>
                    <ul>
                        <li><strong>ChainID 保护</strong>: 防止交易在错误网络上重放</li>
                        <li><strong>网络隔离</strong>: 以太坊签名的交易无法在BSC上执行</li>
                        <li><strong>签名唯一性</strong>: 相同交易在不同网络上签名结果不同</li>
                    </ul>
                </div>
            \`;

            demo.innerHTML = output;
        }
    </script>
</body>
</html>
